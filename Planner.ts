///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>

/**
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter.
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations: Interpreter.InterpretationResult[], currentState: WorldState): PlannerResult[] {
        var errors: Error[] = [];
        var plans: PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result: PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch (err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan: string[];
    }

    export function stringify(result: PlannerResult): string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions

    class NodeState {
        constructor(
            public state: WorldState,
            public command: string) { }

        // TODO: Proper implementation... (Check all the elements in the world state)
        compareTo(other: NodeState): number {
            return 0;
        }
    }

    class StateGraph implements Graph<NodeState>{
        outgoingEdges(node: NodeState): Edge<NodeState>[] {
            var outgoing: Edge<NodeState>[] = [];
            var actions: string[] = [];

            // Can pick up if arm is not holding something, and stack isn't empty
            if (node.state.holding == null && node.state.stacks[node.state.arm].length != 0) {
                actions.push("p");
            }
            if (node.state.arm < node.state.stacks.length - 1) {
                actions.push("r");
            }
            if (node.state.arm > 0) {
                actions.push("l");
            }

            // To be able to drop, check that the arm is holding something and that inside/ontop is legit
            if (node.state.holding != null) {
                var holding: string = node.state.holding;
                var stack: string[] = node.state.stacks[node.state.arm];
                var topObject: string = stack[stack.length - 1];

                // Using isValidGoal() function in Interpreter to check physical laws
                if (Interpreter.isValidGoal("inside", node.state, holding, topObject) ||
                    Interpreter.isValidGoal("ontop", node.state, holding, topObject)) {
                    actions.push("d");
                }
            }

            for (var i = 0; i < actions.length; i++) {
                var edge: Edge<NodeState> = new Edge<NodeState>();
                // Copy the contents of current WorldState
                var nextWorldState: WorldState = JSON.parse(JSON.stringify(node.state));
                if (actions[i] == "p") {
                    nextWorldState.holding = nextWorldState.stacks[nextWorldState.arm].pop();
                    edge.from = node;
                    edge.to = new NodeState(nextWorldState, "p");
                    edge.cost = 1;
                    outgoing.push(edge);
                } else if (actions[i] == "r") {
                    nextWorldState.arm += 1;
                    edge.from = node;
                    edge.to = new NodeState(nextWorldState, "r");
                    edge.cost = 1;
                    outgoing.push(edge);
                } else if (actions[i] == "l") {
                    nextWorldState.arm -= 1;
                    edge.from = node;
                    edge.to = new NodeState(nextWorldState, "l");
                    edge.cost = 1;
                    outgoing.push(edge);
                } else if (actions[i] == "d") {
                    nextWorldState.stacks[nextWorldState.arm].push(nextWorldState.holding);
                    nextWorldState.holding = null;
                    edge.from = node;
                    edge.to = new NodeState(nextWorldState, "d");
                    outgoing.push(edge);
                }

            }

            return outgoing;
        }

        compareNodes(a: NodeState, b: NodeState): number {
            return a.compareTo(b);
        }
    }

    /**
     * The core planner function. The code here is just a template;
     * you should rewrite this function entirely. In this template,
     * the code produces a dummy plan which is not connected to the
     * argument `interpretation`, but your version of the function
     * should be such that the resulting plan depends on
     * `interpretation`.
     *
     *
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d". The code shows how to build a plan. Each step of the plan can
     * be added using the `push` method.
     */
    function planInterpretation(interpretation: Interpreter.DNFFormula, state: WorldState): string[] {
        // TODO: Implement a proper heuristics function
        var h = (n: NodeState) => 0;
        var searchResult: SearchResult<NodeState> = aStarSearch(new StateGraph(), new NodeState(state, null), isGoal, h, 10);
        var plan: string[] = [];

        for (var i = 0; i < searchResult.path.length; i++) {
            var node: NodeState = searchResult.path[i];
            if (node.command != null) {
                plan.push(node.command);
            }
        }

        return plan;

        function isGoal(node: NodeState): boolean {
            for (var i = 0; i < interpretation.length; i++) {
                var conjunctionFlag: boolean = true;

                for (var j = 0; j < interpretation[i].length; j++) {
                    if (!isLiteralGoal(interpretation[i][j], node.state)) {
                        conjunctionFlag = false;
                        break;
                    }
                }

                if (conjunctionFlag) {
                    return true;
                }
            }

            return false;
        }

        function isLiteralGoal(literal: Interpreter.Literal, state: WorldState): boolean {
            var columnIndex: number = Interpreter.getColumnIndex(literal.args[0], state);
            var stackIndex: number = Interpreter.getStackIndex(literal.args[0], columnIndex, state);

            switch (literal.relation) {
                case "holding":
                    return literal.args[0] == state.holding;
                case "inside":
                    if (Interpreter.isInside([literal.args[1]], columnIndex, stackIndex - 1, state)) {
                        return true;
                    }
                    break;
                case "ontop":
                    if (Interpreter.isOnTop([literal.args[1]], columnIndex, stackIndex - 1, state)) {
                        return true;
                    }
                    break;
                case "leftof":
                    if (Interpreter.isLeftOf([literal.args[1]], columnIndex, state)) {
                        return true;
                    }
                    break;
                case "rightof":
                    if (Interpreter.isRightOf([literal.args[1]], columnIndex, state)) {
                        return true;
                    }
                    break;
                case "beside":
                    if (Interpreter.isBeside([literal.args[1]], columnIndex, state)) {
                        return true;
                    }
                    break;
                case "above":
                    if (Interpreter.isAbove([literal.args[1]], columnIndex, stackIndex, state)) {
                        return true;
                    }
                    break;
                case "under":
                    if (Interpreter.isUnder([literal.args[1]], columnIndex, stackIndex + 1, state)) {
                        return true;
                    }
                    break;
            }

            return false;
        }
    }

}
